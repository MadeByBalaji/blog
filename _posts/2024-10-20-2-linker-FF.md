---
title: Why 2 Linker script in STM32CubeIDE
description: STMCubeIDE has 2 Linkerscript what is their use
date: 2024-09-09 11:33:00 -0530
categories: [Firmware Fortress]
tags: [linkerscript,stm,cubeide]
image:
  path: /assets/img/blog/2024/stm-2-linker/cube.jpg
  lqip: /assets/img/blog/2024/stm-2-linker/cube.jpg
---

# Why Two Linker Scripts? 

Understanding `FLASH.ld` and `RAM.ld` in STM32CubeIDE

When working with STM32CubeIDE to build embedded applications, you may notice that two linker scripts are generated by default:

* `STM32F446RETX_FLASH.ld`
* `STM32F446RETX_RAM.ld`

However, during the build process, only **one** linker script is used. This raises a common question: **Why are two linker scripts generated, and what purpose do they serve?**
Let’s explore the reasons behind this and how you can switch between them depending on your development needs.

---

## Why Two Linker Scripts Are Generated

STM32CubeIDE generates two linker scripts to give you the flexibility to configure your program to run either from **Flash** or **RAM**. Both have distinct use cases:

### 1. Flash-based Execution (`STM32F446RETX_FLASH.ld`)

* **Purpose**: This is the default script for most embedded projects. It configures the program to run from Flash memory, which is non-volatile.
* **Why Use Flash?**: Flash retains data even after power cycles. It’s perfect for production code that needs to persist across reboots.

### 2. RAM-based Execution (`STM32F446RETX_RAM.ld`)

* **Purpose**: This script is used for running the entire application from RAM. RAM is volatile but offers faster access times.
* **Why Use RAM?**: Ideal for **debugging** and **testing**, since it avoids the need to frequently erase and write to Flash memory. This significantly speeds up development.

---

## How the Linker Scripts Work

### Flash Linker Script (`STM32F446RETX_FLASH.ld`)

This script places:

* Program code (`.text`) → **Flash**
* Initialized data (`.data`) → **RAM**
* Uninitialized data (`.bss`) → **RAM**

```ld
MEMORY
{
  FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 512K
  RAM   (xrw) : ORIGIN = 0x20000000, LENGTH = 128K
}
```

> Note: The `.data` section is special — it's **executed from RAM (VMA)** but **stored in Flash (LMA)**.
> You can learn more about VMA vs LMA in this [blog post](https://balajimail9.wixsite.com/blog/post/understanding-linker-scripts-vma-and-lma-explained).

---

### RAM Linker Script (`STM32F446RETX_RAM.ld`)

This script places everything — code, initialized data, and uninitialized data — in RAM. Flash is ignored.

```ld
MEMORY
{
  RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 128K
}
```

Used primarily for:

* Debug builds
* Temporary testing
* Fast code iteration

---

## When to Use Each Linker Script

| Linker Script        | When to Use                     | Pros                           | Cons                                        |
| -------------------- | ------------------------------- | ------------------------------ | ------------------------------------------- |
| `FLASH.ld` (default) | Production builds               | Non-volatile, persistent       | Slower than RAM for code access             |
| `RAM.ld`             | Debugging, testing, prototyping | Fast execution, easy to modify | Volatile, not suitable for final deployment |

---

## Does STM32CubeIDE Use Both Linker Scripts?

No. Only **one** script is active per build.

* **Default**: `STM32F446RETX_FLASH.ld`
* **Optional**: You can switch manually to `STM32F446RETX_RAM.ld` for RAM-based execution

---

## Switching to the RAM Linker Script in STM32CubeIDE

Here’s how to switch:

1. **Right-click your project** → **Properties**
2. Navigate to **C/C++ Build > Settings**
3. Under **MCU GCC Linker > General**, change the Linker Script file from
   `STM32F446RETX_FLASH.ld` → `STM32F446RETX_RAM.ld`
4. Click **Apply**, then **Rebuild Project**

Your application will now use the RAM-based layout for execution.

---

## Conclusion

STM32CubeIDE provides two linker scripts — one for **Flash** and one for **RAM** — to help developers manage memory layout depending on the context:

* Use **Flash** linker script for production-ready builds that must persist across power cycles.
* Use **RAM** linker script when debugging or testing code that needs to be modified and re-run frequently.

Understanding and switching between these linker scripts can speed up your development process and help you optimize your embedded application workflow.

